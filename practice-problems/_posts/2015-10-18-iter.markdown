---
layout: post
title:  "Iterables"
date:   2015-10-18 11:14:11
category: Practice Problems
---

## Concepts
<ol style="width: 75%">
<li> What method(s) must **iterables** have?   </li>
<blockquote class="solution-4">`__iter__`</blockquote>
<li>What method(s) must **iterators** have?  </li>
<blockquote class="solution-4">`__iter__` AND `__next__`</blockquote>
<li>What data type does `__iter__` return? </li>
<blockquote class="solution-4">iterator</blockquote>
<li>What data type does `__next__` return?</li>
<blockquote class="solution-4">whatever type each element of the sequence is</blockquote>
<li>Is a **generator** an iterable or an iterator?  </li>
<blockquote class="solution-4">iterator</blockquote>
<li>What keyword in the body of a function makes that function return a generator object?  </li>
<blockquote class="solution-4">`yield`</blockquote>
<li>How is `yield` different from `return`?    </li>
<blockquote class="solution-4">`yield` does not close the frame. `yield` outputs a value, and keeps the frame open until `StopIteration` is raised.</blockquote>
<li>When you call `next` on a generator, the body starts executing at what line? At what line will it stop? At what line will it start the next time you call `next`?  </li>
<blockquote class="solution-4">execution starts at the first line of the body and stops after the line with `yield` is executed. when `next` is called again, execution picks up at the line right after the `yield` statement (where it last left off) and stops after another `yield` execution *or* if there are no more lines in the body.</blockquote>
<li>What happens when you call `list` on an iterable or an iterator? What happens if you call it a second time on the same objects?  </li>
<blockquote class="solution-4">when you call `list` on an iterable or an iterator, Python calls `iter` on it and then attempts to construct a list with the `next` element until `StopIteration` is reached, then returns the constructed list.</blockquote>
<li>Can you iterate through an iterable in a for loop? Can you iterate through an iterator in a for loop?  </li>
<blockquote class="solution-4">you can use both iterables and iterators in a for loop.</blockquote> 
</ol>

<a class="solution-toggle-4 btn btn-default">TOGGLE SOLUTION</a>

<a class="anchor" name="wwpp"></a>  
## What would Python print?
The following classes define an iterable representing the sequence of multiples for any given number and the iterator that returns the next value in the sequence. The sequence goes up to 1000.

    class Multiples:
        def __init__(self, num):
            self.num = num
        
        def __iter__(self):
            return MultiplesIterator(self.num)
    
    class MultiplesIterator:
        def __init__(self, num):
            self.num = num
            self.curr = num
        
        def __iter__(self):
            return self
        
        def __next__(self):
            if self.curr >= 1000:
                raise StopIteration
            val = self.curr
            self.curr = self.curr + self.num
            return val
            
What will the following lines output?

<pre><code>>>> hundreds = Multiples(100)<br>>>> next(hundreds)
<span class="solution-3">TypeError: 'Multiples' object is not an iterator</span>
>>> next(iter(hundreds))
<span class="solution-3">100</span>
>>> next(iter(hundreds))
<span class="solution-3">100</span>
>>> i = iter(hundreds)
>>> i is iter(hundreds)
<span class="solution-3">False</span>
>>> i is iter(i)
<span class="solution-3">True</span>
>>> next(i)
<span class="solution-3">100</span>
>>> next(i)
<span class="solution-3">200</span>
>>> list(hundreds)
<span class="solution-3">[100, 200, 300, 400, 500, 600, 700, 800, 900]</span>
>>> list(i)
<span class="solution-3">[300, 400, 500, 600, 700, 800, 900]</span>
>>> list(hundreds)
<span class="solution-3">[100, 200, 300, 400, 500, 600, 700, 800, 900]</span>
>>> list(i)
<span class="solution-3">[]</span>
>>> for i in hundreds:
...     print(i)
<span class="solution-3">5<br>25<br>125<br>625</span>
>>> for x in i:
...     print(x)</code></pre>

<p class="solution-6">**Explanation**: `Multiples`'s `__iter__` method always returns a *new instance* of `MultiplesIterator`, whereas `MultiplesIterator`'s `__iter__` simply returns itself. For iterables, calling `iter` will reset the iterator, but since iterators just return themselves, they do not reset.</p>

<a class="solution-toggle-3 btn btn-default">TOGGLE SOLUTION</a> &nbsp;
<a class="solution-toggle-6 btn btn-default">TOGGLE EXPLANATION</a>

<a class="anchor" name="code"></a>  
## Writing code
Fill in the following definition of a generator function which yields every number from `1` to `n` and prints `'m was a factor'` if the previous number, `m`, was a factor of `n`. See the doctests for an example.
  
<pre><code>def print_factor(n):
    """
    >>> gen = print_factor(8)
    >>> next(gen)
    1
    >>> next(gen)
    1 was a factor
    2
    >>> next(gen)
    2 was a factor
    3
    >>> next(gen)
    4
    >>> next(gen)
    4 was a factor
    5
    """
    <span class="solution-2-prompt">"*** YOUR CODE HERE ***"</span>
    <span class="solution-2-p">curr = 1
while curr <= n:
    yield curr
    if n % curr == 0:
        print(str(curr) + " was a factor")
    curr += 1</span></code></pre>

<a class="solution-toggle-2-p btn btn-default">TOGGLE SOLUTION</a>