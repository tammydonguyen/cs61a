---
layout: post
title:  "Week 7 Quiz"
date:   2015-06-04 11:00:00
categories: quizzes
---

[This week's slides](https://docs.google.com/a/berkeley.edu/presentation/d/1iWAC72SmQ8H6olLTkuUqovPqe_vbKO2jCv68eCbNTIo/edit?usp=sharing)  
[Link to form](http://goo.gl/forms/98LV91x4xH)  

---

### Concepts
1. Big-O notation denotes a(n) ________ bound on runtime.  
2. What is ordering of Big-O growth rates from fastest to slowest?  
3. How are Tree objects different from tree ADT's that we've worked with previously?   

<!-- <a class="btn btn-default solution-toggle">TOGGLE SOLUTION</a>

<blockquote class="solution">
1. Big-O notation denotes an upper bound on runtime. O(f(n)) tells us that the change in runtime of some function as the input size increases grows no faster than f(n). <br/>
2. O(1) < O(log(n)) < O(n) < O(n^2) < O(2^n). Note that I'm using the less than sign to denote "is a better (faster) runtime". Recall that we care about how fast these functions grow, not what their values are. <br/>
3. Tree objects are instances of the Tree class. We can access it's attributes by using <code>t.label</code> and <code>t.children</code> rather than calling the functions <code>label(t)</code> and <code>children(t)</code>. More importantly, since can access and modify these attributes, Tree objects are mutable. The getter functions for the tree ADT only tell us what the values of the tree are, but do not allow us to modify them.
</blockquote> -->

---

### Problems  
1. What is the Big-O runtime of the following function?  
<blockquote class="solution-2"><b><i>Hint:</i></b> Use the addition technique in the slides! How many operations are done in the <code>for</code> first iteration? The second...? Is there a pattern? Another hint: what does total end up being?</blockquote>
{% highlight python %}
def foo(n):
    total = 0
    for i in range(1, n):
        while i > 1:
            i = i//2
            total += 1
    return total
{% endhighlight %}

<a class="btn btn-default solution-toggle-2">TOGGLE HINT</a>
